#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdbool.h>

// --- Defini√ß√£o da Estrutura (Struct) ---
// Representa uma pe√ßa do jogo
typedef struct {
    char nome; // Tipo da pe√ßa ('I', 'O', 'T', 'L', etc.)
    int id;    // Identificador √∫nico da ordem de cria√ß√£o
} Peca;

// --- Constantes e Vari√°veis Globais da Fila ---
#define MAX_PECAS 8       // Capacidade m√°xima da Fila de pe√ßas futuras
Peca fila[MAX_PECAS];     // O vetor de structs que armazena as pe√ßas
int frente = 0;           // √çndice da pe√ßa na frente (a ser jogada)
int tras = -1;            // √çndice da √∫ltima pe√ßa inserida
int contadorPecas = 0;    // Contador atual de pe√ßas na fila
int contadorIDGlobal = 0; // ID sequencial para garantir unicidade da pe√ßa

// --- Prot√≥tipos das Fun√ß√µes ---
void limparBuffer();
Peca gerarPeca();
void inicializarFila();
void exibirFila();
void inserirPeca(Peca novaPeca); // Enqueue
Peca jogarPeca();                // Dequeue

// =========================================================================
//                  I. FUN√á√ïES DE APOIO E GERA√á√ÉO
// =========================================================================

/**
 * @brief Limpa o buffer de entrada do teclado.
 */
void limparBuffer() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF) {}
}

/**
 * @brief Gera uma nova pe√ßa com ID √∫nico e tipo aleat√≥rio.
 * @return A nova pe√ßa gerada.
 */
Peca gerarPeca() {
    Peca nova;
    char tipos[] = {'I', 'O', 'T', 'L', 'J', 'S', 'Z'}; // Tipos cl√°ssicos de Tetris
    int indiceAleatorio = rand() % 7; // Gera √≠ndice de 0 a 6
    
    nova.nome = tipos[indiceAleatorio];
    nova.id = contadorIDGlobal++; // Atribui ID e incrementa o contador global
    
    printf("\n[GERADO] Nova peca: [%c %d]\n", nova.nome, nova.id);
    return nova;
}

/**
 * @brief Inicializa a fila preenchendo-a com o n√∫mero fixo de pe√ßas.
 */
void inicializarFila() {
    srand(time(NULL)); // Inicializa o gerador de n√∫meros aleat√≥rios
    printf("--- Inicializando Fila de Pecas (Max: %d) ---\n", MAX_PECAS);
    
    for (int i = 0; i < 5; i++) { // Inicializa com 5 elementos, como pedido
        // A fun√ß√£o inserirPeca j√° cuida da l√≥gica da Fila Circular
        inserirPeca(gerarPeca()); 
    }
    printf("‚úÖ Fila inicializada com sucesso.\n");
}


// =========================================================================
//                  II. OPERA√á√ïES DA FILA CIRCULAR
// =========================================================================

/**
 * @brief Insere uma nova pe√ßa no final da fila (Enqueue).
 * @param novaPeca A pe√ßa a ser inserida.
 */
void inserirPeca(Peca novaPeca) {
    if (contadorPecas == MAX_PECAS) {
        printf("\n‚ùå ERRO: Fila de pecas futuras cheia. Nao e possivel inserir.\n");
        return;
    }
    
    // L√≥gica da Fila Circular: O pr√≥ximo "tr√°s" √© (tr√°s + 1) % MAX_PECAS
    tras = (tras + 1) % MAX_PECAS;
    fila[tras] = novaPeca;
    contadorPecas++;
    
    // printf("‚úÖ Peca [%c %d] inserida no final (tras: %d).\n", novaPeca.nome, novaPeca.id, tras);
}

/**
 * @brief Remove a pe√ßa da frente da fila (Dequeue) e simula o ato de jogar.
 * @return A pe√ßa que foi removida.
 */
Peca jogarPeca() {
    Peca pecaRemovida;
    
    if (contadorPecas == 0) {
        printf("\n‚ùå ERRO: Fila vazia. Nao ha pecas para jogar.\n");
        // Retorna uma pe√ßa vazia para indicar erro
        pecaRemovida.nome = '\0'; 
        pecaRemovida.id = -1;
        return pecaRemovida;
    }
    
    // Pega a pe√ßa da frente
    pecaRemovida = fila[frente];
    
    // L√≥gica da Fila Circular: O pr√≥ximo "frente" √© (frente + 1) % MAX_PECAS
    frente = (frente + 1) % MAX_PECAS;
    contadorPecas--;
    
    printf("\n--- JOGAR PECA ---\n");
    printf("üî• Peca jogada: [%c %d] (Tipo: %c, ID: %d)\n", pecaRemovida.nome, pecaRemovida.id, pecaRemovida.nome, pecaRemovida.id);
    
    return pecaRemovida;
}

/**
 * @brief Exibe o estado atual da fila, mostrando o tipo e ID de cada pe√ßa.
 */
void exibirFila() {
    printf("\n================= FILA DE PECAS FUTURAS =================\n");
    if (contadorPecas == 0) {
        printf(" A fila esta vazia.\n");
        printf("-------------------------------------------------------\n");
        return;
    }

    printf(" Capacidade: %d/%d (Frente: %d, Tras: %d)\n", contadorPecas, MAX_PECAS, frente, tras);
    printf(" Fila de Pecas: ");

    int i = frente;
    int count = 0;

    // Percorre a Fila Circular
    while (count < contadorPecas) {
        printf("[%c %d]", fila[i].nome, fila[i].id);
        
        // Move para o pr√≥ximo √≠ndice de forma circular
        i = (i + 1) % MAX_PECAS;
        count++;
        
        if (count < contadorPecas) {
            printf(" -> ");
        }
    }
    
    printf("\n-------------------------------------------------------\n");
}


// =========================================================================
//                  III. FUN√á√ÉO PRINCIPAL (MENU)
// =========================================================================

int main() {
    int opcao;
    
    // 1. Inicializa a Fila e as pe√ßas iniciais
    inicializarFila();
    
    do {
        // 2. Exibe o estado atual da fila
        exibirFila();

        // 3. Exibe o menu de op√ß√µes
        printf("\n================ OPCOES DE ACAO ================\n");
        printf(" Codigo | Acao\n");
        printf("------------------------------------------------\n");
        printf(" 1      | Jogar peca (Dequeue)\n");
        printf(" 2      | Inserir nova peca (Enqueue)\n");
        printf(" 0      | Sair\n");
        printf("------------------------------------------------\n");
        printf(" Escolha uma opcao: ");

        if (scanf("%d", &opcao) != 1) {
            opcao = -1; // Sinaliza erro de leitura
            limparBuffer();
        } else {
            limparBuffer();
        }

        // 4. Executa a a√ß√£o escolhida
        switch (opcao) {
            case 1:
                // Simula o jogador usando a pe√ßa da frente
                jogarPeca();
                break;
            case 2:
                // Simula o sistema gerando e adicionando uma nova pe√ßa
                inserirPeca(gerarPeca());
                break;
            case 0:
                printf("\nüëã Jogo encerrado. Pe√ßas futuras descartadas!\n");
                break;
            default:
                printf("\n‚ö†Ô∏è Opcao invalida. Tente novamente.\n");
        }
    } while (opcao != 0);

    return 0;
}
