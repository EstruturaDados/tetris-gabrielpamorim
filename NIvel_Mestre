#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdbool.h>

// --- I. DEFINI√á√ïES DE STRUCTS E CONSTANTES ---

// Ficha da Pe√ßa
typedef struct {
    char nome; // Tipo da pe√ßa ('I', 'O', 'T', 'L', etc.)
    int id;    // Identificador √∫nico
} Peca;

// Capacidades
#define MAX_FILA 5    // Capacidade da Fila Circular de pe√ßas futuras
#define MAX_PILHA 3   // Capacidade m√°xima da Pilha de reserva

// --- II. VARI√ÅVEIS GLOBAIS DE ESTRUTURA ---

// Fila Circular (Implementa√ß√£o com Array)
Peca filaPecas[MAX_FILA];
int frente = 0;           // √çndice da pe√ßa na frente (Dequeue)
int tras = -1;            // √çndice da √∫ltima pe√ßa inserida (Enqueue)
int contadorFila = 0;     // N√∫mero atual de pe√ßas na fila

// Pilha (Implementa√ß√£o com Array)
Peca pilhaReserva[MAX_PILHA];
int topoPilha = -1;       // √çndice do topo (-1 = vazia)

// ID para gera√ß√£o de pe√ßas
int contadorIDGlobal = 0; // ID sequencial para garantir unicidade da pe√ßa

// --- III. PROT√ìTIPOS DAS FUN√á√ïES ---
void limparBuffer();
Peca gerarPeca();
void inicializarEstruturas();
void exibirEstadoAtual();

// Opera√ß√µes da Fila
void inserirFila(Peca novaPeca);
Peca removerFila();

// Opera√ß√µes da Pilha
bool push(Peca peca);
Peca pop();
Peca peekPilha();

// A√ß√µes do Jogador
void acao_jogarPeca();
void acao_reservarPeca();
void acao_usarReserva();
void acao_trocaSimples();
void acao_trocaMultipla();


// =========================================================================
//                  IV. FUN√á√ïES DE APOIO E GERA√á√ÉO
// =========================================================================

void limparBuffer() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF) {}
}

/**
 * @brief Gera uma nova pe√ßa com ID √∫nico e tipo aleat√≥rio.
 * @return A nova pe√ßa gerada.
 */
Peca gerarPeca() {
    Peca nova;
    char tipos[] = {'I', 'O', 'T', 'L', 'J', 'S', 'Z'};
    int indiceAleatorio = rand() % 7;
    
    nova.nome = tipos[indiceAleatorio];
    nova.id = contadorIDGlobal++;
    
    // printf("[GERADO] Peca: [%c %d]\n", nova.nome, nova.id);
    return nova;
}

/**
 * @brief Exibe o estado da Fila e da Pilha.
 */
void exibirEstadoAtual() {
    printf("\n================= ESTADO ATUAL =================\n");
    
    // 1. Exibir Fila Circular
    printf("FILA de Pecas (%d/%d): ", contadorFila, MAX_FILA);
    if (contadorFila == 0) {
        printf("Vazia.\n");
    } else {
        int i = frente;
        int count = 0;
        // Percorre a Fila, come√ßando pela frente (FIFO)
        while (count < contadorFila) {
            printf("[%c %d]", filaPecas[i].nome, filaPecas[i].id);
            i = (i + 1) % MAX_FILA; // L√≥gica Circular
            count++;
            if (count < contadorFila) {
                printf(" -> ");
            }
        }
        printf("\n");
    }

    // 2. Exibir Pilha Linear
    printf("PILHA de Reserva (Topo -> Base) (%d/%d): ", topoPilha + 1, MAX_PILHA);
    if (topoPilha == -1) {
        printf("Vazia.\n");
    } else {
        // Percorre a Pilha, come√ßando pelo topo (LIFO)
        for (int i = topoPilha; i >= 0; i--) {
            printf("[%c %d]", pilhaReserva[i].nome, pilhaReserva[i].id);
            if (i > 0) {
                printf(" -> ");
            }
        }
        printf("\n");
    }
    printf("------------------------------------------------\n");
}

/**
 * @brief Inicializa a Fila e a Pilha.
 */
void inicializarEstruturas() {
    srand(time(NULL));
    
    // Inicializa a Fila com MAX_FILA elementos
    for (int i = 0; i < MAX_FILA; i++) {
        inserirFila(gerarPeca()); 
    }
    
    // Inicializa a Pilha com 2 elementos para permitir testes de push/pop e troca em bloco
    push(gerarPeca());
    push(gerarPeca());
    
    printf("‚úÖ Estruturas inicializadas (Fila: %d/%d, Pilha: %d/%d).\n", 
           contadorFila, MAX_FILA, topoPilha + 1, MAX_PILHA);
}


// =========================================================================
//                  V. OPERA√á√ïES B√ÅSICAS
// =========================================================================

// --- Fila Circular ---

void inserirFila(Peca novaPeca) {
    // N√£o verifica contadorFila aqui, pois a verifica√ß√£o √© feita na fun√ß√£o de a√ß√£o
    tras = (tras + 1) % MAX_FILA;
    filaPecas[tras] = novaPeca;
    contadorFila++;
}

Peca removerFila() {
    Peca pecaRemovida = {'\0', -1};
    
    if (contadorFila == 0) return pecaRemovida;
    
    pecaRemovida = filaPecas[frente];
    frente = (frente + 1) % MAX_FILA;
    contadorFila--;
    
    return pecaRemovida;
}

// --- Pilha Linear ---

bool push(Peca peca) {
    if (topoPilha == MAX_PILHA - 1) {
        // printf("\n‚ùå Pilha de Reserva Cheia.\n");
        return false;
    }
    topoPilha++;
    pilhaReserva[topoPilha] = peca;
    return true;
}

Peca pop() {
    Peca pecaRemovida = {'\0', -1};

    if (topoPilha == -1) {
        // printf("\n‚ùå Pilha de Reserva Vazia.\n");
        return pecaRemovida;
    }
    
    pecaRemovida = pilhaReserva[topoPilha];
    topoPilha--;
    return pecaRemovida;
}

/**
 * @brief Retorna a pe√ßa do topo SEM remov√™-la (Peek).
 */
Peca peekPilha() {
    Peca pecaTopo = {'\0', -1};
    if (topoPilha == -1) return pecaTopo;
    return pilhaReserva[topoPilha];
}


// =========================================================================
//                  VI. A√á√ïES ESTRAT√âGICAS
// =========================================================================

/**
 * @brief A√ß√£o 1: Remove a pe√ßa da fila e adiciona uma nova pe√ßa (mant√©m a Fila cheia).
 */
void acao_jogarPeca() {
    printf("\n--- ACAO: JOGAR PECA ---\n");
    if (contadorFila == 0) {
        printf("‚ö†Ô∏è Fila vazia! Nao ha pecas para jogar.\n");
        return;
    }

    Peca jogada = removerFila();
    printf("üî• Peca jogada: [%c %d]\n", jogada.nome, jogada.id);

    // Rep√µe a pe√ßa na Fila
    inserirFila(gerarPeca());
    printf("-> Nova peca adicionada a Fila. Fila mantida com %d pecas.\n", contadorFila);
}

/**
 * @brief A√ß√£o 2: Move a pe√ßa da frente da fila para o topo da pilha.
 */
void acao_reservarPeca() {
    printf("\n--- ACAO: RESERVAR PECA ---\n");
    if (contadorFila == 0) {
        printf("‚ö†Ô∏è Nao ha pecas na Fila para reservar.\n");
        return;
    }

    Peca reservada = filaPecas[frente]; // Pega a peca sem remover ainda

    if (push(reservada)) {
        removerFila(); // Remove da fila somente se o push foi bem sucedido
        printf("üì¶ Peca reservada: [%c %d] movida da Fila para o Topo da Pilha.\n", reservada.nome, reservada.id);
        
        // Rep√µe a pe√ßa na Fila
        inserirFila(gerarPeca());
        printf("-> Nova peca adicionada a Fila. Fila mantida com %d pecas.\n", contadorFila);
    } else {
        printf("‚ùå Pilha de Reserva Cheia! Nao foi possivel reservar a peca [%c %d].\n", reservada.nome, reservada.id);
    }
}

/**
 * @brief A√ß√£o 3: Remove a pe√ßa do topo da pilha e adiciona uma nova pe√ßa √† fila.
 */
void acao_usarReserva() {
    printf("\n--- ACAO: USAR PECA RESERVADA ---\n");
    
    Peca usada = pop();

    if (usada.id != -1) {
        printf("‚≠ê Peca reservada usada: [%c %d] removida do Topo da Pilha.\n", usada.nome, usada.id);
        
        // Rep√µe a pe√ßa na Fila
        inserirFila(gerarPeca());
        printf("-> Nova peca adicionada a Fila. Fila mantida com %d pecas.\n", contadorFila);
    } else {
         printf("‚ö†Ô∏è Pilha de Reserva Vazia. Nao ha pecas para usar.\n");
    }
}

/**
 * @brief A√ß√£o 4: Substitui a pe√ßa da frente da fila com o topo da pilha.
 */
void acao_trocaSimples() {
    printf("\n--- ACAO: TROCA SIMPLES (Fila[Frente] <-> Pilha[Topo]) ---\n");
    
    if (contadorFila == 0) {
        printf("‚ö†Ô∏è Fila vazia! Nao e possivel realizar a troca.\n");
        return;
    }
    if (topoPilha == -1) {
        printf("‚ö†Ô∏è Pilha vazia! Nao e possivel realizar a troca.\n");
        return;
    }

    Peca tempFila = filaPecas[frente]; // Pega a pe√ßa da frente
    Peca tempPilha = pilhaReserva[topoPilha]; // Pega a pe√ßa do topo

    // 1. Troca: Coloca a pe√ßa da pilha na frente da fila
    filaPecas[frente] = tempPilha;
    
    // 2. Troca: Coloca a pe√ßa da fila no topo da pilha
    pilhaReserva[topoPilha] = tempFila;

    printf("üîÑ Troca Simples realizada:\n");
    printf("   Fila[Frente] agora e [%c %d]\n", tempPilha.nome, tempPilha.id);
    printf("   Pilha[Topo] agora e [%c %d]\n", tempFila.nome, tempFila.id);
}

/**
 * @brief A√ß√£o 5: Troca as tr√™s primeiras pe√ßas da fila com as tr√™s pe√ßas da pilha.
 */
void acao_trocaMultipla() {
    printf("\n--- ACAO: TROCA MULTIPLA (3 da Fila <-> 3 da Pilha) ---\n");

    if (contadorFila < MAX_PILHA) { // Precisa de 3 pe√ßas na Fila
        printf("‚ùå Fila com menos de %d pecas. Troca nao permitida.\n", MAX_PILHA);
        return;
    }
    if (topoPilha < MAX_PILHA - 1) { // Precisa de 3 pe√ßas na Pilha (topoPilha = 2)
        printf("‚ùå Pilha com menos de %d pecas. Troca nao permitida.\n", MAX_PILHA);
        return;
    }

    Peca temp;
    int indiceFila = frente;

    // A troca √© feita elemento por elemento
    for (int i = 0; i < MAX_PILHA; i++) {
        // Posi√ß√£o na Pilha: MAX_PILHA - 1 - i (Para ir do Topo para Base: 2, 1, 0)
        int indicePilha = MAX_PILHA - 1 - i; 

        // 1. Guarda a pe√ßa da Fila
        temp = filaPecas[indiceFila];

        // 2. Move a pe√ßa da Pilha para a Fila
        filaPecas[indiceFila] = pilhaReserva[indicePilha];

        // 3. Move a pe√ßa guardada da Fila para a Pilha
        pilhaReserva[indicePilha] = temp;

        // Avan√ßa o √≠ndice da Fila de forma circular
        indiceFila = (indiceFila + 1) % MAX_FILA;
    }

    printf("üîÑ Troca M√∫ltipla realizada entre os %d primeiros da Fila e todos da Pilha.\n", MAX_PILHA);
}


// =========================================================================
//                  VII. FUN√á√ÉO PRINCIPAL (MENU)
// =========================================================================

int main() {
    int opcao;
    
    inicializarEstruturas();
    
    do {
        exibirEstadoAtual();

        printf("\n================ OPCOES ESTRATEGICAS ================\n");
        printf(" Codigo | Acao\n");
        printf("-----------------------------------------------------\n");
        printf(" 1      | Jogar peca (Da Fila) [DEQUEUE]\n");
        printf(" 2      | Reservar peca (Fila -> Pilha)\n");
        printf(" 3      | Usar peca reservada (Da Pilha) [POP]\n");
        printf(" 4      | Troca SIMPLES (Fila[Frente] <-> Pilha[Topo])\n");
        printf(" 5      | Troca MULTIPLA (3 da Fila <-> 3 da Pilha)\n");
        printf(" 0      | Sair\n");
        printf("-----------------------------------------------------\n");
        printf(" Escolha uma opcao: ");

        if (scanf("%d", &opcao) != 1) {
            opcao = -1;
            limparBuffer();
        } else {
            limparBuffer();
        }

        switch (opcao) {
            case 1:
                acao_jogarPeca();
                break;
            case 2:
                acao_reservarPeca();
                break;
            case 3:
                acao_usarReserva();
                break;
            case 4:
                acao_trocaSimples();
                break;
            case 5:
                acao_trocaMultipla();
                break;
            case 0:
                printf("\nüëã Jogo encerrado. O gerenciador de pecas foi desligado.\n");
                break;
            default:
                printf("\n‚ö†Ô∏è Opcao invalida. Tente novamente.\n");
        }
    } while (opcao != 0);

    return 0;
}
